/**
 * Copyright (c) 2021 Dongdong Kong. All rights reserved.
 * This work is licensed under the terms of the MIT license.
 * For a copy, see <https://opensource.org/licenses/MIT>.
 */

// var pkgs = require('users/kongdd/pkgs:pkgs.js');
var pkg_vis    = require('users/kongdd/pkgs:pkg_vis.js');
var pkg_join   = require('users/kongdd/pkgs:pkg_join.js');
var pkg_index    = require('users/kongdd/pkgs:pkg_index.js');
var pkg_landsat  = require('users/kongdd/pkgs:pkg_landsat.js');
// var pkg_classify = require('users/kongdd/pkgs:pkg_classify.js');

function merge_dict() {
    var ans = {};
    var obj;
    for (var i = 0; i < arguments.length; ++i) {
        obj = arguments[i];
        for (var j in obj) {
            ans[j] = obj[j];
        }
    }
    return ans;
}

var pkgs = merge_dict(pkg_vis, pkg_join, pkg_index, pkg_landsat);
pkgs.merge_dict = merge_dict;

pkgs.dir = function (obj) {
    for (var j in obj) {
        print(j);  // ": ", obj[j]
    }
};

// pkgs['agg']    = pkg_agg;
// pkgs['export'] = pkg_export;
// pkgs['trend']  = pkg_trend;
// pkgs['date']   = pkg_date;




/**
 * -----------------------------------------------------------------------------
 * ### GEE dplyr
 */
pkgs.set_date = function (img) {
    return img.set('date', img.date().format('YYYY-MM-dd'));
}

/**
 * mutate and transform
 * 
 * @description
 * - `mutate_expr`: unable to guess the bandNames from `expr`
 * @note Unlike `mutate`, `transform` is unable to use new bands in the creating
 * process.
 * 
 * @param indexes function names that stored in `pkgs`. It is assumed that
 *    bandName is same as `index` for `mutate`, while `transform` has no that
 *    constraint.
 * @param options
 * - `include_origin`: whether to include original bands.
 * - `func` (not used for `mutate_expr`): `func` is applied in each `img_new`
 *    generated by `exprs`.
 * @returns function
 * @example
 * mutate_expr(exprs, {func: maskDiff})
 * mutate(['NDVI'], {func: maskDiff})
 */
pkgs.mutate = function (indexes, options) {
    if (!Array.isArray(indexes)) indexes = [indexes];
    options = options || {};

    options.type = options.type || typeof (indexes[0]);
    if (options.type == "string" && pkgs[indexes[0]]) {
        options.type = "namedFunc";
    }
    if (options.include_origin === undefined) options.include_origin = false;

    // for (var i in indexes) indexes[i] = indexes[i].toUpperCase();
    return function (img) {
        // var ans = ee.Image(ee.Image([]).copyProperties(img, img.propertyNames()));
        // var bands = ee.List([]);
        for (var i in indexes) {
            var index = indexes[i];
            var img_new;
            if (options.type == "string") { // expression
                img_new = img.expression(index);
            } else if (options.type == "namedFunc") {
                img_new = pkgs[index](img);
            } else if (options.type == "function") {
                img_new = index(img);
            }
            if (options.func) img_new = options.func(img_new);
            // bands = bands.cat(img_new.bandNames().get(0));
            img = img.addBands(img_new);
        }
        if (!options.include_origin) img = img.select(indexes);
        return pkgs.set_date(img);
    };
};

pkgs.transform = function (indexes, options) {
    if (!Array.isArray(indexes)) indexes = [indexes];
    options = options || {};

    options.type = options.type || typeof (indexes[0]);
    if (options.type == "string" && pkgs[indexes[0]]) {
        options.type = "namedFunc";
    }
    if (options.include_origin === undefined) options.include_origin = false;
    // for (var i in indexes) indexes[i] = indexes[i].toUpperCase();
    return function (img) {
        var ans = ee.Image(ee.Image([]).copyProperties(img, img.propertyNames()));
        for (var i in indexes) {
            var index = indexes[i];
            var img_new;
            if (options.type == "string") { // expression
                img_new = img.expression(index);
            } else if (options.type == "namedFunc") {
                img_new = pkgs[index](img);
            } else if (options.type == "function") {
                img_new = index(img);
            }
            if (options.func) img_new = options.func(img_new);
            ans = ans.addBands(img_new);
        }
        if (!options.include_origin) ans = img.addBands(ans);
        return pkgs.set_date(ans);
    };
};

exports = pkgs;
